# Паттерны

## 2 Строитель (Builder)
#### Порождающий паттерн
Отделяет конструирование сложного объекта от его представления так, что в результате одного и того же процесса конструирования могут получаться разные представления.

### Используют в случаях когда:

### Плюсы
 1) Позволяет изменять внутренне представление объекта;
 2) Изолирует код, реализующий конструирование и представление;
 3) Дает более тонкий контроль над процессом конструирования; 

### Минусы
1) Алгоритм создания сложного объекта не должен зависеть от того, из каких частей состоит объект и как они стыкуются между собой;
2) Процесс конструирования должен обеспечивать различные представления конструируемого объекта;

## 5 Цепочка обязанностей (Chain Of Responsibility)
#### Поведенческий паттерн
Предназначен для организации в системе уровней ответственности.
Данный паттерн позволяет передавать задачи на обработку последовательно по цепочке. Каждый последующий обработчик решает, может ли он обработать запрос сам и стоит ли передавать запрос дальше.

### Применение
1) В разрабатываемой системе имеется группа объектов, которые могут обрабатывать сообщения определенного типа.
2) Все сообщения должны быть обработаны хотя бы одним объектом системы;
3) Сообщения в системе обрабатываются по схеме "обработай сам либо перешли другому", то есть одни сообщения обрабатываются на том уровне, где они получены, а другие пересылаются объектам иного уровня.


`Внимание` Вместо хранения ссылок на всех кандидатов-получателей запроса, каждый отправитель хранит единственную ссылку на начало цепочки, а каждый получать имеет единственную ссылку на своего преемника - последующий элемент в цепочке.

## 6 Фабричный метод (Factory Method)
#### Порождающий паттерн
Определяет интерфейс для создания объекта, но оставляет подклассам решение о том, на основании какого класса создавать объект.
Фабричный метод позволяет классу делегировать создание подклассов.

### Используют в случаях когда:
 Классу заранее неизвестно, объекта каких подклассов ему необходимо создавать.
 Класс спроектирован так, чтобы объекты которые он создает, специфицировались подклассами.
 Класс делегирует свои обязанности одному из нескольких вспомогательных подклассов, и планируется локализовать знание о том, какой класс принимает эти обязанности на себя
 
### Плюсы
 1) Позволяет сделать код создания объектов более универсальным, не привязываясь к конкретным классам, а оперируя лишь общим интерфейс;
 2) Позволяет установить связь между параллельными иерархиями классов; 
### Минусы
 1) Необходимость создавать наследника общего интерфейса для каждого нового типа объекта;

## 7 Стратегия (Strategy)
#### Поведенческий паттерн
Предназначен для определения семейства алгоритмов, инкапсуляции каждого из них и обеспечения их взаимозаменяемости. Это позволяет выбирать алгоритм путем определения соответствующего класса. Данный паттерн позволяет менять выбранный алгоритм независимо от объектов-клиентов, которые его используют.

### Применение
Когда в одном и том же месте в зависимости от текущего состояния система(или ее окружения) должны использоваться различные алгоритмы

### Плюсы
1) Инкапсуляция реализации различных алгоритмов, система становится независимой от возможных изменений бизнес-правил;
2) Вызов всех алгоритмов одним стандартным образом;
3) Отказ от использования переключателей и условных операторов;

### Минусы
1) Создание дополнительных объектов (усложнение программы);
2) Клиент должен знать отличия стратегий, чтобы выбрать необходимую; 


## 8 Состояние (state pattern)
#### Поведенческий паттерн

Идея паттерна Состояния заключается в том, что программа может находиться в одном из нескольких состояний, которые все время сменяют друг друга.
Набор этих состояний, а также переходов между ними, предопределен и конечен.

### Подход можно применять и к отдельным объектам. Например:
Объект "Документ" может принимать состояния: Черновик, Модерация и Опубликован.
В опубликованном состоянии метод не будет делать ничего.

Паттерн предлагает создать отдельные объекты для каждого состояния, в котором может пребывать объект, а затем вынести туда поведения, соответствующие этим состояниям.
Вместо хранения кода всех состояний, первоначальный объект, называемый контекстом, будет содержать ссылку на один из объектов-состояний и делегировать ему работу, зависящую от состояния.

Благодаря тому, что объекты состояний будут иметь общий интерфейс, контекст сможет делегировать работу состоянию, не привязываясь к его классу.

Поведение контекста можно будет изменить в любой момент, подключив к нему другой объект-состояние.

### Паттерн должен применяться:
1) Когда имеется объект, поведение которого кардинально меняется в зависимости от внутреннего состояния, причем типов состояний много
2) Когда код объекта содержит множество больших, похожих друг на друга, условных операторов, которые выбирают поведения в зависимости от текущих значений полей этого объекта.
3) Когда вы сознательно используете табличную модель состояний, построенную на условных операторах, но вынуждены мириться с дублированием кода для похожих состояний и переходов

### Плюсы
1) Избавляет от множества больших условных операторов машины состояний;
2) Концентрирует в одном месте код, связанный с определенным состоянием;
3) Упрощает код контекста;

### Минусы
1) Может неоправданно усложнить код, если состояний мало и они редко меняются;