# Паттерны

## 1 Фасад (Facade)
#### Структурный паттерн
Позволяет скрыть сложность системы путем сведения всех возможных внешних вызовов к одному объекту, делегирующему их соответствующим объектам системы.

Фасад может:
 - Улучшить читабельность и удобство использования программной библиотеки, маскируя взаимодействие с более сложными компонентами за единым API
 - Предоставить контекстно-зависимый интерфейс для более общей функциональности
 - Служить отправной точкой к более широкого рефакторинга монолитных или тесно связанных систем в пользу более слабосвязанного кода

### Применение
Часто используют данный паттерн, когда система сложна или трудна для понимания, поскольку в системе много взаимозависимых классов или потому что ее исходный код недоступен. Шаблон скрывает сложности более крупной системы и обеспечивает более простой интерфейс для клиента. Обычно он включается в себя один класс-оболочку, который содержит набор элементов, требуемых клиентом. Эти участники получают доступ к системе от имени клиента фасада и скрывают детали реализации.

Фасад используют, когда требуется более простой интерфейс к базовому объекту.
В качестве альтернативы можно использовать адаптер, когда оболочка должна учитывать определенный интерфейс и поддерживать полиморфное поведение. Декоратор позволяет добавить или изменять поведение интерфейса во время выполнения.

Обычно используется, когда:
 - Для доступа к сложной системе требуется простой интерфейс
 - Система очень сложна и трудна для понимания
 - Точка входа необходима для каждого уровня многоуровневого программного обеспечения
 - Абстракции и реализации подсистемы тесно связаны
### Пример
В качестве примера можно привести интерфейс автомобиля. Современные автомобили имеют унифицированный интерфейс для водителя, под которым скрывается сложная подсистема.
Благодаря применению электроники, делающей большую часть работы за водителя, тот может с легкостью управлять автомобилем, не задумываюсь, как там все работает.

## 2 Строитель (Builder)
#### Порождающий паттерн
Отделяет конструирование сложного объекта от его представления так, что в результате одного и того же процесса конструирования могут получаться разные представления.

### Используют в случаях когда:

### Плюсы
 1) Позволяет изменять внутренне представление объекта;
 2) Изолирует код, реализующий конструирование и представление;
 3) Дает более тонкий контроль над процессом конструирования; 

### Минусы
1) Алгоритм создания сложного объекта не должен зависеть от того, из каких частей состоит объект и как они стыкуются между собой;
2) Процесс конструирования должен обеспечивать различные представления конструируемого объекта;

## 3 Посетитель (Visitor)


## 4 Команда (Command)


## 5 Цепочка обязанностей (Chain Of Responsibility)
#### Поведенческий паттерн
Предназначен для организации в системе уровней ответственности.
Данный паттерн позволяет передавать задачи на обработку последовательно по цепочке. Каждый последующий обработчик решает, может ли он обработать запрос сам и стоит ли передавать запрос дальше.

### Применение
1) В разрабатываемой системе имеется группа объектов, которые могут обрабатывать сообщения определенного типа.
2) Все сообщения должны быть обработаны хотя бы одним объектом системы;
3) Сообщения в системе обрабатываются по схеме "обработай сам либо перешли другому", то есть одни сообщения обрабатываются на том уровне, где они получены, а другие пересылаются объектам иного уровня.


`Внимание` Вместо хранения ссылок на всех кандидатов-получателей запроса, каждый отправитель хранит единственную ссылку на начало цепочки, а каждый получать имеет единственную ссылку на своего преемника - последующий элемент в цепочке.

## 6 Фабричный метод (Factory Method)
#### Порождающий паттерн
Определяет интерфейс для создания объекта, но оставляет подклассам решение о том, на основании какого класса создавать объект.
Фабричный метод позволяет классу делегировать создание подклассов.

### Используют в случаях когда:
 Классу заранее неизвестно, объекта каких подклассов ему необходимо создавать.
 Класс спроектирован так, чтобы объекты которые он создает, специфицировались подклассами.
 Класс делегирует свои обязанности одному из нескольких вспомогательных подклассов, и планируется локализовать знание о том, какой класс принимает эти обязанности на себя
 
### Плюсы
 1) Позволяет сделать код создания объектов более универсальным, не привязываясь к конкретным классам, а оперируя лишь общим интерфейс;
 2) Позволяет установить связь между параллельными иерархиями классов; 
### Минусы
 1) Необходимость создавать наследника общего интерфейса для каждого нового типа объекта;

## 7 Стратегия (Strategy)
#### Поведенческий паттерн
Предназначен для определения семейства алгоритмов, инкапсуляции каждого из них и обеспечения их взаимозаменяемости. Это позволяет выбирать алгоритм путем определения соответствующего класса. Данный паттерн позволяет менять выбранный алгоритм независимо от объектов-клиентов, которые его используют.

### Применение
Когда в одном и том же месте в зависимости от текущего состояния система(или ее окружения) должны использоваться различные алгоритмы

### Плюсы
1) Инкапсуляция реализации различных алгоритмов, система становится независимой от возможных изменений бизнес-правил;
2) Вызов всех алгоритмов одним стандартным образом;
3) Отказ от использования переключателей и условных операторов;

### Минусы
1) Создание дополнительных объектов (усложнение программы);
2) Клиент должен знать отличия стратегий, чтобы выбрать необходимую; 


## 8 Состояние (state pattern)
#### Поведенческий паттерн

Идея паттерна Состояния заключается в том, что программа может находиться в одном из нескольких состояний, которые все время сменяют друг друга.
Набор этих состояний, а также переходов между ними, предопределен и конечен.

### Подход можно применять и к отдельным объектам. Например:
Объект "Документ" может принимать состояния: Черновик, Модерация и Опубликован.
В опубликованном состоянии метод не будет делать ничего.

Паттерн предлагает создать отдельные объекты для каждого состояния, в котором может пребывать объект, а затем вынести туда поведения, соответствующие этим состояниям.
Вместо хранения кода всех состояний, первоначальный объект, называемый контекстом, будет содержать ссылку на один из объектов-состояний и делегировать ему работу, зависящую от состояния.

Благодаря тому, что объекты состояний будут иметь общий интерфейс, контекст сможет делегировать работу состоянию, не привязываясь к его классу.

Поведение контекста можно будет изменить в любой момент, подключив к нему другой объект-состояние.

### Паттерн должен применяться:
1) Когда имеется объект, поведение которого кардинально меняется в зависимости от внутреннего состояния, причем типов состояний много
2) Когда код объекта содержит множество больших, похожих друг на друга, условных операторов, которые выбирают поведения в зависимости от текущих значений полей этого объекта.
3) Когда вы сознательно используете табличную модель состояний, построенную на условных операторах, но вынуждены мириться с дублированием кода для похожих состояний и переходов

### Плюсы
1) Избавляет от множества больших условных операторов машины состояний;
2) Концентрирует в одном месте код, связанный с определенным состоянием;
3) Упрощает код контекста;

### Минусы
1) Может неоправданно усложнить код, если состояний мало и они редко меняются;