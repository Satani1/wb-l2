# Паттерны

## 1 Фасад (Facade)
#### Структурный паттерн
Позволяет скрыть сложность системы путем сведения всех возможных внешних вызовов к одному объекту, делегирующему их соответствующим объектам системы.

Фасад может:
 - Улучшить читабельность и удобство использования программной библиотеки, маскируя взаимодействие с более сложными компонентами за единым API
 - Предоставить контекстно-зависимый интерфейс для более общей функциональности
 - Служить отправной точкой к более широкого рефакторинга монолитных или тесно связанных систем в пользу более слабосвязанного кода

### Применение
Часто используют данный паттерн, когда система сложна или трудна для понимания, поскольку в системе много взаимозависимых классов или потому что ее исходный код недоступен. Шаблон скрывает сложности более крупной системы и обеспечивает более простой интерфейс для клиента. Обычно он включается в себя один класс-оболочку, который содержит набор элементов, требуемых клиентом. Эти участники получают доступ к системе от имени клиента фасада и скрывают детали реализации.

Фасад используют, когда требуется более простой интерфейс к базовому объекту.
В качестве альтернативы можно использовать адаптер, когда оболочка должна учитывать определенный интерфейс и поддерживать полиморфное поведение. Декоратор позволяет добавить или изменять поведение интерфейса во время выполнения.

Обычно используется, когда:
 - Для доступа к сложной системе требуется простой интерфейс
 - Система очень сложна и трудна для понимания
 - Точка входа необходима для каждого уровня многоуровневого программного обеспечения
 - Абстракции и реализации подсистемы тесно связаны
### Пример
В качестве примера можно привести интерфейс автомобиля. Современные автомобили имеют унифицированный интерфейс для водителя, под которым скрывается сложная подсистема.
Благодаря применению электроники, делающей большую часть работы за водителя, тот может с легкостью управлять автомобилем, не задумываюсь, как там все работает.

## 2 Строитель (Builder)
#### Порождающий паттерн
Отделяет конструирование сложного объекта от его представления так, что в результате одного и того же процесса конструирования могут получаться разные представления.

### Используют в случаях когда:

### Плюсы
 1) Позволяет изменять внутренне представление объекта;
 2) Изолирует код, реализующий конструирование и представление;
 3) Дает более тонкий контроль над процессом конструирования; 

### Минусы
1) Алгоритм создания сложного объекта не должен зависеть от того, из каких частей состоит объект и как они стыкуются между собой;
2) Процесс конструирования должен обеспечивать различные представления конструируемого объекта;

## 3 Посетитель (Visitor)
#### Поведенческий паттерн
Паттерн позволяет добавить новую операцию для целой иерархии классов, не изменяя код этих классов.

### Использование
Если есть вероятность изменения иерархии обслуживаемого класса, либо она будет нестабильной или открытый интерфейс достаточно эффективен для доступа шаблона, то его использование будет вредоносным.

Паттерн посетитель предлагает разместить новое поведение в отдельном классе, вместо того, чтобы множить его сразу в нескольких классах. Объекты, с которыми должно быть связано поведение, не будут выполнять его самостоятельно. Вместо этого вы будете передавать эти объекты в методы посетителя.

Шаблон следует использовать, если:
 - Имеются различные объекты разных классов с разными интерфейсами, но над ними нужно совершать операции зависящие от конкретных классов
 - Необходимо над структурой выполнить различные, усложняющие структуру операции
 - Часто добавляются новые операции над структурой

### Плюсы
- Упрощает добавление операций, работающих со сложными структурами объектов.
- Объединяет родственные операции в одном классе
- Посетитель может накапливать состояние при обходе структуры элементов
### Минусы
- Паттерн не оправдан, если иерархия элементов постоянно меняется
- Может привести к нарушению инкапсуляции элементов
## 4 Команда (Command)
#### Поведенческий паттерн
В данном шаблоне объект используется для инкапсуляции всей информации, необходимой для выполнения действия или запуская события в более позднее время.
Эта информация включается имя метода, объект, которому принадлежит метод, и значения параметров метода.

С шаблоном команды всегда связаны четыре термина: `команда`, `получатель`, `вызывающая сторона`,`клиент`.
Командный объект знает о получателе и вызывает метод получателя. Значения параметров метода приемника хранятся в команде. Объект получателя для выполнения этих методов также сохраняется в объекте команды путем агрегирования.
Затем получатель выполняет работу, когда вызывается метод в команде. Заклинатель `execute()` объект знает, как выполнить команду, и, возможно, ведет учет выполнения команды. Объект вызывающего объекта, объекты команды и объекты получателя удерживаются объектом клиента, клиент решает, какие объекты получателя он назначает объектам команды, а какие команды назначает вызывающему объекту. Клиент решает, какие команды выполнять в каких точках. Чтобы выполнить команды, он передает объект команды вызывающему объекту.
### Цель
Создание структуры, в которой класс-отправитель и класс-получатель не зависят друг от друга напрямую. Организация обратного вызова к классу, который включает в себя класс-отправитель.
### Использование
Использование данного шаблона может решить проблемы:
 - Следует избегать связывания инициатора запроса с конкретным запросом. То есть следует избегать жестко запрограммированных запросов.
 - Должна быть возможность настроить объект, который вызывает запрос, с запросом

Реализация запроса непосредственно в класс негибкая, потому что она связывает класс с конкретным запросом во время компиляции, что делает указание запроса во время выполнения.

Использование данного паттерна описывает следующее решение:
- Определите отдельные(командные) объекты, которые инкапсулируют запрос
- Класс делегирует запрос объекту команды вместо того, чтобы напрямую реализовывать конкретный запрос.
Это позволяет настроить класс с объектом команды, который используется для выполнения запроса. Класс больше не связан с конкретным запросом и не знает(независим) о том, как выполняется запрос.
## 5 Цепочка обязанностей (Chain Of Responsibility)
#### Поведенческий паттерн
Предназначен для организации в системе уровней ответственности.
Данный паттерн позволяет передавать задачи на обработку последовательно по цепочке. Каждый последующий обработчик решает, может ли он обработать запрос сам и стоит ли передавать запрос дальше.

### Применение
1) В разрабатываемой системе имеется группа объектов, которые могут обрабатывать сообщения определенного типа.
2) Все сообщения должны быть обработаны хотя бы одним объектом системы;
3) Сообщения в системе обрабатываются по схеме "обработай сам либо перешли другому", то есть одни сообщения обрабатываются на том уровне, где они получены, а другие пересылаются объектам иного уровня.


`Внимание` Вместо хранения ссылок на всех кандидатов-получателей запроса, каждый отправитель хранит единственную ссылку на начало цепочки, а каждый получать имеет единственную ссылку на своего преемника - последующий элемент в цепочке.

## 6 Фабричный метод (Factory Method)
#### Порождающий паттерн
Определяет интерфейс для создания объекта, но оставляет подклассам решение о том, на основании какого класса создавать объект.
Фабричный метод позволяет классу делегировать создание подклассов.

### Используют в случаях когда:
 Классу заранее неизвестно, объекта каких подклассов ему необходимо создавать.
 Класс спроектирован так, чтобы объекты которые он создает, специфицировались подклассами.
 Класс делегирует свои обязанности одному из нескольких вспомогательных подклассов, и планируется локализовать знание о том, какой класс принимает эти обязанности на себя
 
### Плюсы
 1) Позволяет сделать код создания объектов более универсальным, не привязываясь к конкретным классам, а оперируя лишь общим интерфейс;
 2) Позволяет установить связь между параллельными иерархиями классов; 
### Минусы
 1) Необходимость создавать наследника общего интерфейса для каждого нового типа объекта;

## 7 Стратегия (Strategy)
#### Поведенческий паттерн
Предназначен для определения семейства алгоритмов, инкапсуляции каждого из них и обеспечения их взаимозаменяемости. Это позволяет выбирать алгоритм путем определения соответствующего класса. Данный паттерн позволяет менять выбранный алгоритм независимо от объектов-клиентов, которые его используют.

### Применение
Когда в одном и том же месте в зависимости от текущего состояния система(или ее окружения) должны использоваться различные алгоритмы

### Плюсы
1) Инкапсуляция реализации различных алгоритмов, система становится независимой от возможных изменений бизнес-правил;
2) Вызов всех алгоритмов одним стандартным образом;
3) Отказ от использования переключателей и условных операторов;

### Минусы
1) Создание дополнительных объектов (усложнение программы);
2) Клиент должен знать отличия стратегий, чтобы выбрать необходимую; 


## 8 Состояние (state pattern)
#### Поведенческий паттерн

Идея паттерна Состояния заключается в том, что программа может находиться в одном из нескольких состояний, которые все время сменяют друг друга.
Набор этих состояний, а также переходов между ними, предопределен и конечен.

### Подход можно применять и к отдельным объектам. Например:
Объект "Документ" может принимать состояния: Черновик, Модерация и Опубликован.
В опубликованном состоянии метод не будет делать ничего.

Паттерн предлагает создать отдельные объекты для каждого состояния, в котором может пребывать объект, а затем вынести туда поведения, соответствующие этим состояниям.
Вместо хранения кода всех состояний, первоначальный объект, называемый контекстом, будет содержать ссылку на один из объектов-состояний и делегировать ему работу, зависящую от состояния.

Благодаря тому, что объекты состояний будут иметь общий интерфейс, контекст сможет делегировать работу состоянию, не привязываясь к его классу.

Поведение контекста можно будет изменить в любой момент, подключив к нему другой объект-состояние.

### Паттерн должен применяться:
1) Когда имеется объект, поведение которого кардинально меняется в зависимости от внутреннего состояния, причем типов состояний много
2) Когда код объекта содержит множество больших, похожих друг на друга, условных операторов, которые выбирают поведения в зависимости от текущих значений полей этого объекта.
3) Когда вы сознательно используете табличную модель состояний, построенную на условных операторах, но вынуждены мириться с дублированием кода для похожих состояний и переходов

### Плюсы
1) Избавляет от множества больших условных операторов машины состояний;
2) Концентрирует в одном месте код, связанный с определенным состоянием;
3) Упрощает код контекста;

### Минусы
1) Может неоправданно усложнить код, если состояний мало и они редко меняются;