## 2. Что выведет программа? Объяснить вывод программы. Объяснить как работают defer’ы и порядок их вызовов.
```go
package main
 
import (
    "fmt"
)
 
func test() (x int) {
    defer func() {
        x++
    }()
    x = 1
    return
}
 
 
func anotherTest() int {
    var x int
    defer func() {
        x++
    }()
    x = 1
    return x
}
 
 
func main() {
    fmt.Println(test())
    fmt.Println(anotherTest())
}
```

### Ответ

```go
2
1
```
`defer` - это ключевое слово, которое используется для отложенного выполнения функции или метода до тех пор, пока текущая функция не завершится. Когда встречается оператор `defer`, добавляется вызов функции или метода в стек отложенных вызовов, а затем продолжает выполнение текущей функции. Далее после завершнеия внешней(внутри который был совершен отложенный вызов) функции отложенные функции\методы выполняются в порядке `LIFO`(Last In - First Out).
Правила работы:
- Аргументы оцениваются при вычислении оператора `defer`
```go
func anotherTest() int {
    var x int
    defer func() {
        x++ // в отложенной функции x будет равен 0 и затем произойдет инкрементирование
    }()
    x = 1
    return x
}
```
- LIFO
- Отложенные функции могут считывать и присваивать именованные возвращаемые значения функций
```go
func test() (x int) {
    defer func() {
        x++ // в данном случае defer считает возвращаемое значение функции test()
    }()
    x = 1
    return
}
```

В данной программе функция `test` использует возвращаемое значение и поэтому функция `defer` удается увеличить переменную на 1.
А в функции `anotherTest` обратная ситуация. `defer` считывается переменную `x`, когда она равна 0 и она увеличится с 0 до 1. А также этот отложенный вызов никак не повлияет на переменную `x` в теле самой функции `anotherTest`, тк `defer` не имеет к ней доступа.
