# WB-L2

# Устная подготовка
## 1. Что выведет программа? Объяснить вывод программы.

```go
package main
 
import (
    "fmt"
)
 
func main() {
    a := [5]int{76, 77, 78, 79, 80}
    var b []int = a[1:4]
    fmt.Println(b)
}
```

### Ответ
```go
[77 78 79]
```
В программе создается массив из 5 элементов. Затем на базе этого массива создается слайс [1:4], емкость слайса будет равна 4, а длина 3. В результате окажутся элементы `[77 78 79]`. Так как первый индекс среза является включительным, а второй нет.
## 2. Что выведет программа? Объяснить вывод программы. Объяснить как работают defer’ы и порядок их вызовов.

```go
package main
 
import (
    "fmt"
)
 
func test() (x int) {
    defer func() {
        x++
    }()
    x = 1
    return
}
 
 
func anotherTest() int {
    var x int
    defer func() {
        x++
    }()
    x = 1
    return x
}
 
 
func main() {
    fmt.Println(test())
    fmt.Println(anotherTest())
}
```

### Ответ
```go
2
1
```
`defer` - это ключевое слово, которое используется для отложенного выполнения функции или метода до тех пор, пока текущая функция не завершится. Когда встречается оператор `defer`, добавляется вызов функции или метода в стек отложенных вызовов, а затем продолжает выполнение текущей функции. Далее после завершнеия внешней(внутри который был совершен отложенный вызов) функции отложенные функции\методы выполняются в порядке `LIFO`(Last In - First Out).
Правила работы: 
 - Аргументы оцениваются при вычислении оператора `defer`
```go
func anotherTest() int {
    var x int
    defer func() {
        x++ // в отложенной функции x будет равен 0 и затем произойдет инкрементирование
    }()
    x = 1
    return x
}
```
 - LIFO
 - Отложенные функции могут считывать и присваивать именованные возвращаемые значения функций
```go
func test() (x int) {
    defer func() {
        x++ // в данном случае defer считает возвращаемое значение функции test()
    }()
    x = 1
    return
}
```

В данной программе функция `test` использует возвращаемое значение и поэтому функция `defer` удается увеличить переменную на 1. 
А в функции `anotherTest` обратная ситуация. `defer` считывается переменную `x`, когда она равна 0 и она увеличится с 0 до 1. А также этот отложенный вызов никак не повлияет на переменную `x` в теле самой функции `anotherTest`, тк `defer` не имеет к ней доступа.

## 3. Что выведет программа? Объяснить вывод программы. Объяснить внутреннее устройство интерфейсов и их отличие от пустых интерфейсов.
```go
package main
 
import (
    "fmt"
    "os"
)
 
func Foo() error {
    var err *os.PathError = nil
    return err
}
 
func main() {
    err := Foo()
    fmt.Println(err)
    fmt.Println(err == nil)
}
```
### Ответ
```go
<nil>
false
```
Базовая структура является равно `nil`, однако интерфейс таковым не является. Интерфейс может быть равен `nil` только в случае, если тип и значение равны `nil`.
## Устройство интерфейсов
## 4. Что выведет программа? Объяснить вывод программы.
```go
package main
 
func main() {
    ch := make(chan int)
    go func() {
        for i := 0; i < 10; i++ {
            ch <- i
        }
    }()
 
    for n := range ch {
        println(n)
    }
}
```
### Ответ
```go
0
1
2
3
4
5
6
7
8
9
fatal error: all goroutines are asleep - deadlock!
```
Произойдет `deadlock` в цикле, где числа вычитаются из канала. Это происходит, потому что после окончания записи в канал данных он не был закрыт. Следовательно цикл будет вечно ждать данные из канала. Необходимо закрыть канал `close(ch)` после цикла в горутине.
## 5. Что выведет программа? Объяснить вывод программы.
```go
package main
 
type customError struct {
     msg string
}
 
func (e *customError) Error() string {
    return e.msg
}
 
func test() *customError {
     {
         // do something
     }
     return nil
}
 
func main() {
    var err error
    err = test()
    if err != nil {
        println("error")
        return
    }
    println("ok")
}
```
### Ответ
```go
error
```
Интерфейс равен `nil`, только в случае если тип и значения оба равны `nil`. В данной программме функция `test` возвращает интерфейс, в котором данные будут `nil`, но тип будет определен, как `customError` => в терминале будет `error`

## 6. Что выведет программа? Объяснить вывод программы. Рассказать про внутреннее устройство слайсов и что происходит при передаче их в качестве аргументов функции.
```go
package main
 
import (
  "fmt"
)
 
func main() {
  var s = []string{"1", "2", "3"}
  modifySlice(s)
  fmt.Println(s)
}
 
func modifySlice(i []string) {
  i[0] = "3"
  i = append(i, "4")
  i[1] = "5"
  i = append(i, "6")
}
```
### Ответ
```go
[3 2 3]
```

Слайс является структурой состоящей из: указателя на базовый массив, длины, емкости.
В Go передача параметров в функцию происходит по значению, следовательно слайс `s` и слайс `i` это два разных слайса, но имеющие указатель на один базовый массив. То есть если изменить слайс `i`, то изменится и слайс `s`.
Но если при некоторых операциях слайс необходимо увеличить, то он сменит базовый массив(произойдет копирование старого массива в новое место в памяти и к нему добавится новое значение). Как раз при использовании функции `append`, если емкость слайса меньше при вставке новых элементов, то функция вернет новый слайс с указателем на другой базовый массив, в который соответственно копируется старый и добавляются к нему новые элементы. 

Увеличение емкости происходит по формуле: 
```
   < 256     =>    cap*2
   < 512     =>    cap*1.63
   < 1024    =>    cap*1.44
   < 2048    =>    cap*1.35
   < 4096    =>    cap*1.3
```   
В данной программе `i[0] = "3"` изменится значения в обоих слайсах, тк они ссылаются на один базовый массив. Но после первого выполнения функции `append` произойдет выделение нового массива, и после чего слайсы `s` и `i` будут указывать на разные массивы. Поэтому последующее изменение `i[1]="5"` не отразится на слайсе `s`. 
## 7. Что выведет программа? Объяснить вывод программы.
```go
package main
 
import (
    "fmt"
    "math/rand"
    "time"
)
 
func asChan(vs ...int) <-chan int {
   c := make(chan int)
 
   go func() {
       for _, v := range vs {
           c <- v
           time.Sleep(time.Duration(rand.Intn(1000)) * time.Millisecond)
      }
 
      close(c)
  }()
  return c
}
 
func merge(a, b <-chan int) <-chan int {
   c := make(chan int)
   go func() {
       for {
           select {
               case v := <-a:
                   c <- v
              case v := <-b:
                   c <- v
           }
      }
   }()
 return c
}
 
func main() {
 
   a := asChan(1, 3, 5, 7)
   b := asChan(2, 4 ,6, 8)
   c := merge(a, b )
   for v := range c {
       fmt.Println(v)
   }
}
```
### Ответ
```go
1
2
3
4
5
6
8
7
0
0
0
...
```

В функции `merge` используется оператор `select`, у которого нет проверки на то, возвращается или нет стандартное значение переменной из канала. После закрытия каналов `a` и `b` в выходной канал `c` будут отправляться стандартный значения переменной типа `int` - 0.

В языке нет проверки закрытия канала при вычитании из него значений.

Необходимо использовать `waitgroup` и дополнительные `горутины`.
```go
func merge(a, b <-chan int) <-chan int {
    out := make(chan int)
    var wg sync.WaitGroup
    
    wg.Add(2)
    go func(c <-chan int) {
        for value := range c {
            out <- value
        }
        wg.Done()
    }(a)
    
    go func(c <-chan int) {
        for value := range c {
            out <- value
        }
        wg.Done()
    }(b)
    go func() {
        wg.Wait()
        close(out)
    }()
    return out
}
```
